---
description: Simple post-processing in three.js using a triangle that fills the screen.
title: Post-Processing
---

:::caution
this article is a work in progress
:::

Post-processing refers to effects that are applied to an image after rendering. Examples include tone-mapping, blurring, antialiasing, bloom effects, glitch effects, and many more. It typically involves rendering the scene to a render target and then using the target's texture as input to a separate fragment shader.

import App from "@components/examples/techniques/post-processing/simple/app.svelte";

<App client:only />

Three.js provides many of these effects through its post-processing addon, however for simple effects that don't require multiple passes, using the addon might be excessive.

Before explaining how to achieve a simple post-processing render pipeline, its worth explaining render targets and their usage.

## Render Target

A render target is simply something that can be rendered to. By default the render target that a renderer uses is the canvas that is passed into its constructor.

```ts
declare function getCanvas(): HTMLCanvasElement;

const canvas = getCanvas();

const renderer = new WebGLRenderer({
	canvas,
});

renderer.render(scene, camera); // render to the canvas
```

You can create a render target to render the scene to something other than the canvas.

```ts
const target = new WebGLRenderTarget(width, height);
```

Note that the target's width and height do not have to be the same as the canvas width and height and really depends on where and how you intend to use the target's texture.

To draw the scene to the target, the renderer's target needs to be updated.

```ts
renderer.setRenderTarget(target);
renderer.render(scene, camera); // render to the render target
```

When `setRenderTarget` is passed `null`, the target is set to the canvas.

```ts
renderer.setRenderTarget(null);
```

The render target's `texture` is just like any other texture and can be passed as input into three.js materials.

```ts
const material = new MeshBasicMaterial({
	map: target.texture,
});
```

The texture can also be passed as a uniform into a custom shader.

```ts
const uSceneTexture = new Uniform(target.texture);

const material = new RawShaderMaterial({
	fragmentShader,
	uniforms: {
		uSceneTexture,
	},
	vertexShader,
});
```
